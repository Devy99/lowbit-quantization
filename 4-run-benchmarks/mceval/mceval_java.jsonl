{"name":"Java-1","language":"java","prompt":"import java.util.Arrays;\nimport java.util.List;\n\nclass Problem {\n     \/**\n         * Calculate the average account balance based on the closing balances from the past twelve months.\n         *\n         * @param closingBalances A list of closing balances from the past twelve months.\n         * @return The average account balance.\n         *\n         * Example:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Output: 1581.42\n         *\/\n    public static double calculateAverageBalance(List<Double> closingBalances)","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"    public static void main(String[] args) {\n        \/\/ Test the function with the examples from the comment\n        assert Math.abs(calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75)) - 1581.42) < 0.01;\n        assert Math.abs(calculateAverageBalance(Arrays.asList(100.0, 200.0, 300.0, 400.0, 500.0, 600.0, 700.0, 800.0, 900.0, 1000.0, 1100.0, 1200.0)) - 650.0) < 0.01;\n        assert Math.abs(calculateAverageBalance(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0)) - 6.5) < 0.01;\n        System.out.println(\"All tests passed\");\n    }\n}","stop_tokens":[]}
{"name":"Java-2","language":"java","prompt":"class Problem {\n    \/**\n     * Given a positive integer Y indicating the start year, and a positive integer N,\n     * this function finds the Nth leap year after the start year Y.\n     *\n     * @param Y The start year.\n     * @param N The position of the leap year to find.\n     * @return The Nth leap year after the start year Y.\n     *\n     * Example:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     *\/\n    public static int findNthLeapYear(int Y, int N) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"    public static void main(String[] args) {\n        \/\/ Test the function with the examples from the comment\n        assert findNthLeapYear(2000, 4) == 2012;\n        assert findNthLeapYear(1996, 10) == 2032;\n        assert findNthLeapYear(2000, 1) == 2000;\n        System.out.println(\"All tests passed\");\n    }\n}","stop_tokens":[]}
{"name":"Java-3","language":"java","prompt":"class Problem {\n    \/**\n     * Calculate the time needed to obtain the reverse seating order.\n     * For each person, the person who was originally on their left will be on their right, and the person who was originally on their right will be on their left.\n     * \n     * @param N the number of people\n     * @return the time needed in minutes\n     * \n     * Example:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     *\/\n    public static int calculateTimeNeeded(int N) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"    public static void main(String[] args) {\n        \/\/ Test the function with different test cases\n        assert calculateTimeNeeded(7) == 3;\n        assert calculateTimeNeeded(8) == 4;\n        assert calculateTimeNeeded(9) == 4;\n        System.out.println(\"All tests passed\");\n    }\n}","stop_tokens":[]}
{"name":"Java-4","language":"java","prompt":"import java.lang.*;\nimport java.util.*;\n\nclass Problem {\n\n  \/**\n   * Given an array of distinct integers, return all possible permutations of the array.\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   *\/\n  public List<List<Integer>> permute(int[] nums) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"public static void main(String[] args) {\n    Problem solution = new Problem();\n\n    \/\/ Test the function with different test cases\n    assert solution\n      .permute(new int[] { 4, 5, 6 })\n      .equals(\n        Arrays.asList(\n          Arrays.asList(4, 5, 6),\n          Arrays.asList(4, 6, 5),\n          Arrays.asList(5, 4, 6),\n          Arrays.asList(5, 6, 4),\n          Arrays.asList(6, 4, 5),\n          Arrays.asList(6, 5, 4)\n        )\n      );\n    assert solution\n      .permute(new int[] { 7, 8 })\n      .equals(Arrays.asList(Arrays.asList(7, 8), Arrays.asList(8, 7)));\n    assert solution\n      .permute(new int[] { 9 })\n      .equals(Collections.singletonList(Collections.singletonList(9)));\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-5","language":"java","prompt":"import java.util.*;\n\nclass Problem {\n    \/**\n     * Given a number of case-sensitive strings, finds the largest string X, such that either X, or its inverse can be found as a substring of any of the given strings.\n     * \n     * Example:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     *\/\n    public int findLargestSubstring(List<String> strings) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"    public static void main(String[] args) {\n        Problem solution = new Problem();\n\n        \/\/ Test the function with different test cases\n        assert solution.findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\")) == 2;\n        assert solution.findLargestSubstring(Arrays.asList(\"rose\", \"orchid\")) == 2;\n        assert solution.findLargestSubstring(Arrays.asList(\"hello\", \"world\")) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}","stop_tokens":[]}
{"name":"Java-6","language":"java","prompt":"import java.util.*;\n\nclass Problem {\n\n    \/**\n     * Given a grid representing a land divided into square plots, determine the number of distinct oil deposits.\n     * \n     * Parameters:\n     *     grid (char[][]): The grid representing the land. Each character is either '*' for absence of oil or '@' for an oil pocket.\n     * \n     * Returns:\n     *     int: The number of distinct oil deposits in the grid.\n     * \n     * Example:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     *\/\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"    public static void main(String[] args) {\n        \/\/ Test the function with different test cases\n        assert countOilDeposits(new char[][] {{'@', '@', '@'}, {'@', '*', '@'}, {'@', '@', '@'}}) == 1;\n        assert countOilDeposits(new char[][] {{'@', '*', '@'}, {'*', '*', '*'}, {'@', '*', '@'}}) == 4;\n        assert countOilDeposits(new char[][] {{'*', '*', '*', '*', '*'}, {'*', '@', '@', '@', '*'}, {'*', '@', '*', '@', '*'}, {'*', '@', '@', '@', '*'}, {'*', '*', '*', '*', '*'}}) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}","stop_tokens":[]}
{"name":"Java-7","language":"java","prompt":"import java.util.*;\n\nclass Problem {\n    \/**\n     * Given the number of triangles N, determine the maximum number of regions the plane can be divided into.\n     *\n     * Example:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N the number of triangles\n     * @return the maximum number of regions\n     *\/\n    public static int maxRegions(int N) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"    public static void main(String[] args) {\n        \/\/ Test the function with different test cases\n        assert maxRegions(3) == 13;\n        assert maxRegions(4) == 21;\n        assert maxRegions(5) == 31;\n        System.out.println(\"All tests passed\");\n    }\n}","stop_tokens":[]}
{"name":"Java-8","language":"java","prompt":"import java.util.*;\n\nclass Problem {\n\n    \/**\n     * Count the number of words in the given word list that have the given prefix.\n     * \n     * @param wordList: a list of words\n     * @param prefix: the prefix string\n     * @return the number of words with the given prefix\n     * \n     * Example:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     *\/\n    public static int countPrefixWords(List<String> wordList, String prefix) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"    public static void main(String[] args) {\n        \/\/ Test the function with different test cases\n        assert countPrefixWords(Arrays.asList(\"apple\", \"ape\", \"april\", \"ant\", \"an\"), \"ap\") == 3;\n        assert countPrefixWords(Arrays.asList(\"cat\", \"cap\", \"cape\", \"camp\"), \"ca\") == 4;\n        assert countPrefixWords(Arrays.asList(\"dog\", \"dodge\", \"dot\", \"dough\"), \"do\") == 4;\n        System.out.println(\"All tests passed\");\n    }\n}","stop_tokens":[]}
{"name":"Java-9","language":"java","prompt":"import java.util.*;\n\nclass Problem {\n   \/**\n     * Given a list of numbers, determine how many items in the list are twice some other item in the same list.\n     * \n     * Example:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     *\/\n    public static int countDoubles(int[] numbers) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"    public static void main(String[] args) {\n        \/\/ Test the function with different test cases\n        assert countDoubles(new int[]{1, 2, 4, 8, 16}) == 4;\n        assert countDoubles(new int[]{5, 10, 20, 40, 80}) == 4;\n        assert countDoubles(new int[]{3, 6, 12, 24, 48}) == 4;\n        System.out.println(\"All tests passed\");\n    }\n}","stop_tokens":[]}
{"name":"Java-10","language":"java","prompt":"import java.util.*;\n\nclass Problem {\n    \/**\n     * Given the size of the n-teresting space, the starting and ending n-tersection coordinates, and the paths between adjacent n-tersections, determine if it is possible to travel from the starting n-tersection to the ending n-tersection.\n     * \n     * Parameters:\n     * - n: the size of the n-teresting space\n     * - start: the starting n-tersection coordinates\n     * - end: the ending n-tersection coordinates\n     * - paths: paths between adjacent n-tersections in the n-teresting space\n     * \n     * Output:\n     * - If travel is possible, return \"can be travelled\"\n     * - If travel is not possible, return \"cannot be travelled\"\n     *\/\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"    public static void main(String[] args) {\n        \/\/ Test the function with different test cases\n        assert canTravelMaze(2, new int[]{0, 0}, new int[]{2, 2}, new int[][]{{0, 0, 0, 1}, {0, 1, 1, 1}, {1, 1, 1, 2}, {1, 2, 2, 2}}).equals(\"can be travelled\");\n        assert canTravelMaze(2, new int[]{0, 0}, new int[]{2, 2}, new int[][]{{0, 0, 0, 1}, {0, 1, 1, 1}, {1, 1, 2, 1}, {2, 1, 2, 2}}).equals(\"can be travelled\");\n        assert canTravelMaze(2, new int[]{0, 0}, new int[]{2, 2}, new int[][]{{0, 0, 0, 1}, {0, 1, 1, 1}, {1, 1, 2, 1}}).equals(\"cannot be travelled\");\n        System.out.println(\"All tests passed\");\n    }\n}","stop_tokens":[]}
{"name":"Java-11","language":"java","prompt":"import java.util.*;\n\nclass Problem {\n    \/**\n     * The approximate value is calculated by counting the number of common letters\n     * and dividing it by the sum of the lengths of the two words.\n     *\n     * @param word1 The first word.\n     * @param word2 The second word.\n     * @return The approximate value as a reduced fraction.\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6\/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4\/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1\/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     *\/\n    public static String appx(String word1, String word2) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"    public static void main(String[] args) {\n        \/\/ Test the function with different test cases\n        assert appx(\"DOG\", \"CAT\").equals(\"appx(DOG, CAT) = 0\/6\");\n        assert appx(\"HELLO\", \"WORLD\").equals(\"appx(HELLO, WORLD) = 3\/10\");\n        assert appx(\"JAVA\", \"PYTHON\").equals(\"appx(JAVA, PYTHON) = 0\/10\");\n        System.out.println(\"All tests passed\");\n    }\n}","stop_tokens":[]}
{"name":"Java-12","language":"java","prompt":"import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Problem {\n    \/**\n     * Given a date in the format \"MM dd yyyy\", return the weekday of the date.\n     * \n     * Example:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     *\/\n    public static String convertDatesToWeekdays(String date) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"    public static void main(String[] args) {\n        \/\/ Test the function with different test cases\n        assert convertDatesToWeekdays(\"02 05 2024\").equals(\"February 5, 2024 is a Monday\");\n        assert convertDatesToWeekdays(\"01 12 2023\").equals(\"January 12, 2023 is a Thursday\");\n        assert convertDatesToWeekdays(\"09 14 2013\").equals(\"September 14, 2013 is a Saturday\");\n        System.out.println(\"All tests passed\");\n    }\n}","stop_tokens":[]}
{"name":"Java-13","language":"java","prompt":"import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Problem {\n    \/**\n     * Given an array of integers nums and an integer target,\n     * find two numbers such that they add up to target and return their indices.\n     * You may assume that each input would have exactly one solution,\n     * and you may not use the same element twice.\n     * You can return the answer in any order.\n     *\n     * Example 1:\n     * Input: nums = [2,7,11,15], target = 9\n     * Output: [0,1]\n     * Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n     *\n     * Example 2:\n     * Input: nums = [3,2,4], target = 6\n     * Output: [1,2]\n     *\n     * Example 3:\n     * Input: nums = [3,3], target = 6\n     * Output: [0,1]\n     *\/\n  public int[] twoSum(int[] nums, int target) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    Problem solution = new Problem();\n\n    \/\/ Test the function with different test cases\n    assert Arrays.equals(\n      solution.twoSum(new int[] { 1, 3, 7, 9, 2 }, 11),\n      new int[] { 3, 4 }\n    );\n    assert Arrays.equals(\n      solution.twoSum(new int[] { 1, 5, 3, 7, 8 }, 9),\n      new int[] { 0, 4 }\n    );\n    assert Arrays.equals(\n      solution.twoSum(new int[] { 10, 20, 30, 40, 50 }, 90),\n      new int[] { 3, 4 }\n    );\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-14","language":"java","prompt":"class Problem {\n    \/**\n     * Search for the target value in the rotated sorted array.\n     * If the target value exists, return its index; otherwise, return -1.\n     * The array nums is rotated at some unknown pivot k, where 0 <= k < nums.length.\n     * The time complexity of the algorithm must be O(log n).\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     *\/\n    public int search(int[] nums, int target) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"    public static void main(String[] args) {\n        Problem solution = new Problem();\n\n        \/\/ Test the function with different test cases\n        assert solution.search(new int[]{4,5,6,7,0,1,2}, 6) == 2;\n        assert solution.search(new int[]{4,5,6,7,0,1,2}, 7) == 3;\n        assert solution.search(new int[]{1, 3}, 3) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}","stop_tokens":[]}
{"name":"Java-15","language":"java","prompt":"import java.lang.*;\nimport java.util.*;\n\nclass Problem {\n    \/**\n     * Given an integer array arr, calculate the mean of the remaining elements after removing the smallest 5% and largest 5% of the elements.\n     * Return the mean with an error within 10^-5.\n     *\n     * Example 1:\n     * Input: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * Output: 2.00000\n     *\n     * Example 2:\n     * Input: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * Output: 4.00000\n     *\n     * Example 3:\n     * Input: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * Output: 4.77778\n     *\n     * Example 4:\n     * Input: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * Output: 5.27778\n     *\n     * Example 5:\n     * Input: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * Output: 5.29167\n     *\/\n  public double trimMean(int[] arr) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    Problem solution = new Problem();\n\n    \/\/ Test the function with different test cases\n    assert Math.abs(\n      solution.trimMean(new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }) - 5.5\n    ) <\n    1e-5;\n    assert Math.abs(\n      solution.trimMean(new int[] { 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 }) -\n      55.0\n    ) <\n    1e-5;\n    assert Math.abs(\n      solution.trimMean(new int[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }) - 1.0\n    ) <\n    1e-5;\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-16","language":"java","prompt":"import java.lang.*;\nimport java.util.*;\n\nclass Problem {\n    \/**\n     * Check if it is possible to divide the array into n\/2 pairs such that the sum of each pair is divisible by k.\n     *\n     * @param arr the input integer array\n     * @param k the divisor\n     * @return true if it is possible, false otherwise\n     *\n     * Example:\n     * Input: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Output: true\n     * Explanation: The pairs are (1,9), (2,8), (3,7), (4,6), (5,10), and the sum of each pair is divisible by 5.\n     *\n     * Input: arr = [1,2,3,4,5,6], k = 7\n     * Output: true\n     * Explanation: The pairs are (1,6), (2,5), (3,4), and the sum of each pair is divisible by 7.\n     *\n     * Input: arr = [1,2,3,4,5,6], k = 10\n     * Output: false\n     * Explanation: It is not possible to divide the array into n\/2 pairs such that the sum of each pair is divisible by 10.\n     *\/\n  public boolean canArrange(int[] arr, int k) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    Problem solution = new Problem();\n\n    \/\/ Test the function with different test cases\n    assert solution.canArrange(new int[]{1,2,3,4,5,10,6,7,8,9}, 5) == true;\n    assert solution.canArrange(new int[]{1,2,3,4,5,6}, 7) == true;\n    assert solution.canArrange(new int[]{1,2,3,4,5,6}, 10) == false;\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-17","language":"java","prompt":"import java.util.*;\n\nclass Problem {\n\n  \/**\n   * Given a tree with n nodes and edges, and a boolean array hasApple indicating if each node has an apple.\n   * Starting from node 0, return the minimum time required to collect all the apples and return to node 0.\n   *\n   * Example:\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * Output: 8\n   *\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * Output: 6\n   *\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * Output: 0\n   *\/\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    Problem solution = new Problem();\n\n    \/\/ Test the function with different test cases\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { true, false, true, false, true, true, false }\n    ) ==\n    8;\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { true, true, true, true, true, true, true }\n    ) ==\n    12;\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { false,false,true,false,false,true,false }\n    ) ==\n    6;\n\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { false,false,false,false,false,false,false }\n    ) ==\n    0;\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-18","language":"java","prompt":"import java.util.*;\n\nclass Problem {\n    \/**\n     * Given a string s. You should re-order the string using the following algorithm:\n     * 1. Pick the smallest character from s and append it to the result.\n     * 2. Pick the smallest character from s which is greater than the last appended character to the result and append it.\n     * 3. Repeat step 2 until you cannot pick more characters.\n     * 4. Pick the largest character from s and append it to the result.\n     * 5. Pick the largest character from s which is smaller than the last appended character to the result and append it.\n     * 6. Repeat step 5 until you cannot pick more characters.\n     * 7. Repeat the steps from 1 to 6 until you pick all characters from s.\n     * In each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\n     * Return the result string after sorting s with this algorithm.\n     *\/\n    public String sortString(String s)","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"    public static void main(String[] args) {\n        Problem solution = new Problem();\n\n        \/\/ Test the function with different test cases\n        assert solution.sortString(\"aaaabbbbcccc\").equals(\"abccbaabccba\");\n        assert solution.sortString(\"rat\").equals(\"art\");\n        assert solution.sortString(\"leetcode\").equals(\"cdelotee\");\n        System.out.println(\"All tests passed\");\n    }\n}","stop_tokens":[]}
{"name":"Java-19","language":"java","prompt":"import java.util.*;\n\nclass Problem {\n    \/**\n     * Check if it is possible to split the given integer array into two non-empty arrays\n     * with the same average.\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     *\/\n    public boolean splitArraySameAverage(int[] nums) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"public static void main(String[] args) {\n        Problem solution = new Problem();\n\n        \/\/ Test the function with different test cases\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 8}) == true;\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 9}) == false;\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 10}) == true;\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) == true;\n        System.out.println(\"All tests passed\");\n    }\n}","stop_tokens":[]}
{"name":"Java-20","language":"java","prompt":"class Problem {\n    \/**\n     * Given an integer array cost where cost[i] is the cost of ith step on a staircase,\n     * return the minimum cost to reach the top of the floor.\n     * You can either start from the step with index 0 or the step with index 1.\n     *\n     * Example:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * Explanation: You will start at index 1.\n     * - Pay 15 and climb two steps to reach the top.\n     * The total cost is 15.\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * Explanation: You will start at index 0.\n     * - Pay 1 and climb two steps to reach index 2.\n     * - Pay 1 and climb two steps to reach index 4.\n     * - Pay 1 and climb two steps to reach index 6.\n     * - Pay 1 and climb one step to reach index 7.\n     * - Pay 1 and climb two steps to reach index 9.\n     * - Pay 1 and climb one step to reach the top.\n     * The total cost is 6.\n     *\/\n  public int minCostClimbingStairs(int[] cost) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    Problem solution = new Problem();\n\n    \/\/ Test the function with different test cases\n    assert solution.minCostClimbingStairs(new int[] { 10, 15, 20 }) == 15;\n    assert solution.minCostClimbingStairs(\n      new int[] { 1, 100, 1, 1, 1, 100, 1, 1, 100, 1 }\n    ) ==\n    6;\n    assert solution.minCostClimbingStairs(new int[] { 0, 0, 0, 1 }) == 0;\n    System.out.println(\"All tests passed\");\n  }\n}\n","stop_tokens":[]}
{"name":"Java-21","language":"java","prompt":"import java.util.*;\n\nclass Problem {\n    \/**\n     * Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter,\n     * return the number of different transformations among all words.\n     *\n     * Example:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     *\/\n    public int uniqueMorseRepresentations(String[] words) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"    public static void main(String[] args) {\n        Problem solution = new Problem();\n\n        \/\/ Test the function with different test cases\n        assert solution.uniqueMorseRepresentations(new String[]{\"hello\", \"world\", \"hello\"}) == 2;\n        assert solution.uniqueMorseRepresentations(new String[]{\"abc\", \"def\", \"ghi\"}) == 3;\n        assert solution.uniqueMorseRepresentations(new String[]{\"aaa\", \"aaa\", \"aaa\"}) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}","stop_tokens":[]}
{"name":"Java-22","language":"java","prompt":"import java.util.*;\n\nclass Problem {\n    \/**\n     * Given a binary string s and an integer k, return true if every binary string of length k is a substring of s, or false otherwise.\n     *\n     * Example 1:\n     * Input: s = \"00110110\", k = 2\n     * Output: true\n     * Explanation: All binary strings of length 2 (\"00\", \"01\", \"10\", and \"11\") are substrings of s.\n     *\n     * Example 2:\n     * Input: s = \"0110\", k = 1\n     * Output: true\n     * Explanation: All binary strings of length 1 (\"0\" and \"1\") are substrings of s.\n     *\n     * Example 3:\n     * Input: s = \"0110\", k = 2\n     * Output: false\n     * Explanation: The binary string \"00\" is not a substring of s.\n     *\/\n  public boolean hasAllCodes(String s, int k) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    Problem solution = new Problem();\n\n    \/\/ Test the function with different test cases\n    assert solution.hasAllCodes(\"00110110\", 3) == false;\n    assert solution.hasAllCodes(\"00110110\", 2) == true;\n    assert solution.hasAllCodes(\n      \"1111111111111111111111111111111111111111111111111111111111111111\",\n      1\n    ) ==\n    false;\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-23","language":"java","prompt":"class Problem {\n    \/**\n    * Check if the searchWord is a prefix of any word in the sentence.\n    * If searchWord is a prefix of multiple words, return the index of the first matching word.\n    * If searchWord is not a prefix of any word, return -1.\n    * \n    * Example:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    *\/\n  public int isPrefixOfWord(String sentence, String searchWord) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n      Problem solution = new Problem();\n\n      \/\/ Test the function with different test cases\n      assert solution.isPrefixOfWord(\"hello world\", \"wor\") == 2;\n      assert solution.isPrefixOfWord(\"hello world\", \"hell\") == 1;\n      assert solution.isPrefixOfWord(\"hello world\", \"foo\") == -1;\n      System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-24","language":"java","prompt":"class Problem {\n    \/**\n    * Given a string s composed of '(' and ')', the left and right brackets in s may be unbalanced. Each operation can insert a '(' or ')', and calculate the minimum number of insertion operations required. Make the left and right brackets in s balanced.\n    *\n    * Example 1:\n    * Input: s = \"(()))\"\n    * Output: 1\n    * Explanation:  We need to add one '(' at the first of the string to make it balanced: \"((()))\".\n    * Example 2:\n    * Input: s = \"((()))\"\n    * Output: 0\n    *\n    * - s consists of '(' and ')' only.\n    *\/\n public int minInsertions(String s) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"    public static void main(String[] args) {\n        Problem solution = new Problem();\n\n        \/\/ Test the function with different test cases\n        assert solution.minInsertions(\"((()))\") == 0;\n        assert solution.minInsertions(\"()()()\") == 0;\n        assert solution.minInsertions(\"(()))(()\") == 2;\n        assert solution.minInsertions(\"))())(((\") == 6;\n        System.out.println(\"All tests passed\");\n    }\n}","stop_tokens":[]}
{"name":"Java-25","language":"java","prompt":"class Problem {\n  \/**\n  * Given an integer n, return the minimum number of operations required to make all elements in the array arr equal.\n  * The array arr has a length of n, and arr[i] = (2 * i) + 1 for 0 <= i < n.\n  * In one operation, you can select two indices x and y (0 <= x, y < n) and subtract 1 from arr[x] and add 1 to arr[y] (i.e., arr[x] -= 1 and arr[y] += 1).\n  * The goal is to make all elements in arr equal. The test cases will ensure that after performing some operations, all elements in arr can be made equal.\n  *\n  * Example 1:\n  * Input: n = 3\n  * Output: 2\n  * Explanation: arr = [1, 3, 5]\n  * First operation: x = 2, y = 0 -> arr = [2, 3, 4]\n  * Second operation: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * Example 2:\n  * Input: n = 6\n  * Output: 9\n  *\/\n  public int minOperations(int n) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n      Problem solution = new Problem();\n\n      \/\/ Test the function with different test cases\n      assert solution.minOperations(4) == 4;\n      assert solution.minOperations(5) == 6;\n      assert solution.minOperations(7) == 12;\n      System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-26","language":"java","prompt":"class Problem {\n    \/**\n     * Given an integer array `gain` representing the net gain in altitude between consecutive points, return the highest altitude reached.\n     *\n     * Example:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest altitude reached is 1.\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest altitude reached is 0.\n     *\n     * Constraints:\n     * - The length of the `gain` array is between 1 and 100, inclusive.\n     * - Each element in the `gain` array is between -100 and 100, inclusive.\n     *\/\n    public int highestAltitude(int[] gain) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"    public static void main(String[] args) {\n        Problem solution = new Problem();\n\n        \/\/ Test the function with different test cases\n        assert solution.highestAltitude(new int[]{-5,1,5,0,-7}) == 1;\n        assert solution.highestAltitude(new int[]{-4,-3,-2,-1,4,3,2}) == 0;\n        assert solution.highestAltitude(new int[]{-4, -3, -2, -1, 4, 3, 2, 1}) == 0;\n        System.out.println(\"All tests passed\");\n    }\n}","stop_tokens":[]}
{"name":"Java-27","language":"java","prompt":"class Problem {\n    \/**\n     * Given an integer array nums, return the maximum absolute sum of any subarray.\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     *\/\n    public int maxAbsoluteSum(int[] nums) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"public static void main(String[] args) {\n        Problem solution = new Problem();\n\n        \/\/ Test the function with different test cases\n        assert solution.maxAbsoluteSum(new int[]{1,-3,2,3,-4}) == 5;\n        assert solution.maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2}) == 8;\n        assert solution.maxAbsoluteSum(new int[]{-2, -3, 4, -1, -2, 1, 5, -3}) == 7;\n        System.out.println(\"All tests passed\");\n    }\n}","stop_tokens":[]}
{"name":"Java-28","language":"java","prompt":"import java.util.*;\n\nclass Problem {\n    \/**\n     * Given an integer k, return the minimum number of Fibonacci numbers whose sum is equal to k.\n     * Fibonacci numbers are defined as follows:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, for n > 2.\n     * It is guaranteed that there is at least one valid solution for the given k.\n     *\n     * Example 1:\n     * Input: k = 7\n     * Output: 2\n     * Explanation: Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ...\n     * For k = 7, we can get 2 + 5 = 7.\n     *\n     * Example 2:\n     * Input: k = 10\n     * Output: 2\n     * Explanation: For k = 10, we can get 2 + 8 = 10.\n     *\n     * Example 3:\n     * Input: k = 19\n     * Output: 3\n     * Explanation: For k = 19, we can get 1 + 5 + 13 = 19.\n     *\/\n  public int findMinFibonacciNumbers(int k) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    Problem solution = new Problem();\n\n    \/\/ Test the function with different test cases\n    assert solution.findMinFibonacciNumbers(7) == 2;\n    assert solution.findMinFibonacciNumbers(10) == 2;\n    assert solution.findMinFibonacciNumbers(13) == 1;\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-29","language":"java","prompt":"class Problem {\n    \/**\n     * Given two positive integers n and k, find the kth factor of n.\n     * A factor of n is a positive integer that divides n evenly.\n     * Return the kth factor in ascending order. If n has less than k factors, return -1.\n     *\n     * Example 1:\n     * Input: n = 12, k = 3\n     * Output: 3\n     * Explanation: The factors of 12 are [1, 2, 3, 4, 6, 12]. The 3rd factor is 3.\n     *\n     * Example 2:\n     * Input: n = 7, k = 2\n     * Output: 7\n     * Explanation: The factors of 7 are [1, 7]. The 2nd factor is 7.\n     *\n     * Example 3:\n     * Input: n = 4, k = 4\n     * Output: -1\n     * Explanation: The factors of 4 are [1, 2, 4]. There is no 4th factor, so we return -1.\n     *\/\n    public int kthFactor(int n, int k) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"    public static void main(String[] args) {\n        Problem solution = new Problem();\n\n        \/\/ Test the function with different test cases\n        assert solution.kthFactor(100, 3) == 4;\n        assert solution.kthFactor(15, 4) == 15;\n        assert solution.kthFactor(30, 18) == -1;\n        System.out.println(\"All tests passed\");\n    }\n}","stop_tokens":[]}
{"name":"Java-30","language":"java","prompt":"class Problem {\n    \/**\n     * Given a string s consisting of lowercase and uppercase English letters,\n     * you need to make the string \"good\".\n     * A string is considered \"good\" if there are no adjacent characters such that\n     * one is a lowercase letter and the other is the corresponding uppercase letter.\n     * You can choose any adjacent characters in the string and remove them until the string is \"good\".\n     * Return the final \"good\" string.\n     *\n     * Example 1:\n     * Input: s = \"leEeetcode\"\n     * Output: \"leetcode\"\n     * Explanation: You can remove \"Ee\" to make \"leetcode\".\n     *\n     * Example 2:\n     * Input: s = \"abBAcC\"\n     * Output: \"\"\n     * Explanation: There are multiple possible solutions, such as:\n     * - Remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\", then remove \"aA\" to make \"\".\n     * - Remove \"aA\" to make \"abBAcC\", then remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\",\n     *   then remove \"aA\" to make \"\".\n     * No matter the choices, the result is an empty string.\n     *\n     * Example 3:\n     * Input: s = \"s\"\n     * Output: \"s\"\n     * Explanation: The string is already \"good\".\n     *\/\n  public String makeGood(String s) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"public static void main(String[] args) {\n    Problem solution = new Problem();\n\n    \/\/ Test the function with different test cases\n    assert solution.makeGood(\"aAbBcC\").equals(\"\");\n    assert solution.makeGood(\"AaBbCc\").equals(\"\");\n    assert solution.makeGood(\"abcABC\").equals(\"abcABC\");\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-31","language":"java","prompt":"import java.util.*;\n\nclass Problem {\n\n  \/**\n   * Given a string s, split the string and return the maximum number of unique substrings.\n   * The split substrings should be able to reconstruct the original string, and each substring must be unique.\n   *\n   * Example:\n   * Input: s = \"ababccc\"\n   * Output: 5\n   * Explanation: One possible way to split the string is ['a', 'b', 'ab', 'c', 'cc'].\n   *              Splitting the string as ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid, because both 'a' and 'b' appear more than once.\n   *\n   * Note:\n   * - The length of s is between 1 and 16.\n   * - s only contains lowercase English letters.\n   *\/\n  public int maxUniqueSplit(String s) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    Problem solution = new Problem();\n\n    \/\/ Test the function with different test cases\n    assert solution.maxUniqueSplit(\"ababccc\") == 5;\n    assert solution.maxUniqueSplit(\"abcabcabc\") == 6;\n    assert solution.maxUniqueSplit(\"abcdefg\") == 7;\n    assert solution.maxUniqueSplit(\"aaaaaaa\") == 3;\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-32","language":"java","prompt":"class Problem {\n    \/**\n     * Given a list of logs representing folder operations,\n     * return the minimum number of steps required to return to the main folder.\n     *\n     * Example:\n     * Input: logs = [\"d1\/\",\"d2\/\",\"..\/\",\"d21\/\",\".\/\"]\n     * Output: 2\n     * Explanation: Perform the \"..\/\" operation twice to return to the main folder.\n     *\n     * Input: logs = [\"d1\/\",\"d2\/\",\".\/\",\"d3\/\",\"..\/\",\"d31\/\"]\n     * Output: 3\n     *\n     * Input: logs = [\"d1\/\",\"..\/\",\"..\/\",\"..\/\"]\n     * Output: 0\n     *\/\n  public int minOperations(String[] logs) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    Problem solution = new Problem();\n\n    \/\/ Test the function with different test cases\n    assert solution.minOperations(\n      new String[] { \"d1\/\", \"d2\/\", \"..\/\", \"d21\/\", \".\/\", \"..\/\" }\n    ) ==\n    1;\n    assert solution.minOperations(\n      new String[] { \"d1\/\", \"d2\/\", \".\/\", \"d3\/\", \"..\/\", \"d31\/\", \"..\/\" }\n    ) ==\n    2;\n    assert solution.minOperations(\n      new String[] { \"d1\/\", \"..\/\", \"..\/\", \"..\/\", \"d2\/\" }\n    ) ==\n    1;\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-33","language":"java","prompt":"import java.util.*;\n\nclass Problem {\n    \/**\n     * Return the lexicographically smallest string of length n and value k.\n     * The value of a string is the sum of the positions of its characters in the alphabet (starting from 1).\n     * Example:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     *\/\n    public String getSmallestString(int n, int k) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"\n    public static void main(String[] args) {\n        Problem solution = new Problem();\n\n        \/\/ Test the function with different test cases\n        assert solution.getSmallestString(3, 27).equals(\"aay\");\n        assert solution.getSmallestString(5, 73).equals(\"aaszz\");\n        assert solution.getSmallestString(3, 30).equals(\"acz\");\n        System.out.println(\"All tests passed\");\n    }\n}","stop_tokens":[]}
{"name":"Java-34","language":"java","prompt":"class Problem {\n\n  \/\/ Given the number of passengers n, calculate the probability that the last passenger will sit in their own seat.\n  \/\/ @param n The number of passengers.\n  \/\/ @return The probability that the last passenger will sit in their own seat.\n\n  \/\/ Example 1:\n  \/\/ Input: n = 1\n  \/\/ Output: 1.00000\n\n  \/\/ Example 2:\n  \/\/ Input: n = 2\n  \/\/ Output: 0.50000\n\n  \/\/ Example 3:\n  \/\/ Input: n = 3\n  \/\/ Output: 0.50000\n\n  \/\/ Example 4:\n  \/\/ Input: n = 4\n  \/\/ Output: 0.50000\n\n  \/\/ Example 5:\n  \/\/ Input: n = 5\n  \/\/ Output: 0.50000\n\n  \/\/ Example 6:\n  \/\/ Input: n = 100000\n  \/\/ Output: 0.50000\n\n  \/\/ Function to calculate the probability that the last passenger will sit in their own seat\n  public static double calculateProbability(int n) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"public static void main(String[] args) {\n    assert Math.abs(calculateProbability(6) - 0.50000) < 0.00001;\n    assert Math.abs(calculateProbability(10) - 0.50000) < 0.00001;\n    assert Math.abs(calculateProbability(50) - 0.50000) < 0.00001;\n\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-35","language":"java","prompt":"import java.util.HashMap;\nimport java.util.Map;\n\nclass Problem {\n\n  \/**\n   * Given an integer array nums where every element appears three times except for one, which appears only once. Find and return the element that appears only once.\n   *\n   * @param nums An integer array where every element appears three times except for one.\n   * @return The element that appears only once.\n   *\n   * Example:\n   * singleNumber(new int[]{2,2,3,2})\n   * Output: 3\n   *\n   * Example:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Output: 99\n   *\/\n  public static int singleNumber(int[] nums) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    assert singleNumber(new int[] { 6, 1, 6, 6 }) == 1 : \"Test case 1 failed\";\n    assert singleNumber(new int[] { 22, 22, 22, 11, 11, 11, 55 }) ==\n    55 : \"Test case 2 failed\";\n    assert singleNumber(new int[] { -1, 3, -1, 3, -1, 3, 99 }) ==\n    99 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-36","language":"java","prompt":"import java.util.ArrayList;\nimport java.util.List;\n\nclass Problem {\n\n  \/**\n   * Find all stepping numbers in the range [low, high] where a stepping number is defined as a number where each digit is either one more or one less than the adjacent digit.\n   *\n   * @param low The lower bound of the range.\n   * @param high The upper bound of the range.\n   * @return A list of stepping numbers within the range [low, high] sorted in ascending order.\n   *\n   * Example:\n   * findSteppingNumbers(0, 21)\n   * Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   *\/\n  public static List<Integer> findSteppingNumbers(int low, int high) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    assert findSteppingNumbers(0, 21)\n      .equals(\n        new ArrayList<>(List.of(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21))\n      );\n    assert findSteppingNumbers(10, 15).equals(new ArrayList<>(List.of(10, 12)));\n    assert findSteppingNumbers(50, 55).equals(List.of(54));\n\n    System.out.println(\"All tests passed\");\n  }\n}\n","stop_tokens":[]}
{"name":"Java-37","language":"java","prompt":"class Problem {\n\n  \/**\n   * Calculate the number of times the digit 1 appears in all non-negative integers less than or equal to n.\n   *\n   * @param n An integer representing the upper limit.\n   * @return The number of times the digit 1 appears.\n   *\n   * Example:\n   * countDigitOne(13)\n   * Output: 6\n   *\n   * Example:\n   * countDigitOne(0)\n   * Output: 0\n   *\/\n  public static int countDigitOne(int n) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    assert countDigitOne(20) == 12 : \"Test case 1 failed\";\n    assert countDigitOne(55) == 16 : \"Test case 2 failed\";\n    assert countDigitOne(99) == 20 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-38","language":"java","prompt":"class Problem {\n\n  \/**\n   * Given an integer n, determine if it is a power of two.\n   * If it is, return true; otherwise, return false.\n   * A number n is a power of two if there exists an integer x such that n == 2^x.\n   *\n   * @param n The integer to be checked.\n   * @return True if n is a power of two, false otherwise.\n   *\n   * Example:\n   * isPowerOfTwo(1)\n   * Output: true\n   *\n   * Example:\n   * isPowerOfTwo(16)\n   * Output: true\n   *\n   * Example:\n   * isPowerOfTwo(3)\n   * Output: false\n   *\n   * Example:\n   * isPowerOfTwo(4)\n   * Output: true\n   *\n   * Example:\n   * isPowerOfTwo(5)\n   * Output: false\n   *\/\n  public static boolean isPowerOfTwo(int n) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    \/\/ Test cases\n    assert isPowerOfTwo(1024) == true; \/\/ 1024 is 2^10\n    assert isPowerOfTwo(65536) == true; \/\/ 65536 is 2^16\n    assert isPowerOfTwo(14) == false; \/\/ 14 is not a power of two\n\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-39","language":"java","prompt":"class Problem {\n\n  \/**\n   * Given a non-negative integer num, repeatedly add all its digits until the result is a single digit. Return the result.\n   *\n   * @param num The non-negative integer to perform the operation on.\n   * @return The single digit result after repeatedly adding all digits.\n   *\n   * Example:\n   * addDigits(38)\n   * Output: 2\n   *\/\n  public static int addDigits(int num) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    assert addDigits(123) == 6 : \"Test case 1 failed\";\n    assert addDigits(59) == 5 : \"Test case 2 failed\";\n    assert addDigits(0) == 0 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-40","language":"java","prompt":"class Problem {\n\n  \/**\n   * Given a binary matrix mat of size m x n, return the length of the longest continuous line of 1s in the matrix.\n   * The line could be horizontal, vertical, diagonal, or anti-diagonal.\n   *\n   * @param mat The binary matrix.\n   * @return The length of the longest continuous line of 1s.\n   *\n   * Example:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * Output: 3\n   *\/\n  public static int longestLine(int[][] mat) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    assert longestLine(\n      new int[][] {\n        { 1, 1, 0, 0 },\n        { 0, 1, 1, 0 },\n        { 0, 0, 0, 1 },\n        { 1, 0, 0, 0 },\n      }\n    ) ==\n    3;\n    assert longestLine(\n      new int[][] {\n        { 1, 0, 0, 1 },\n        { 0, 1, 1, 0 },\n        { 1, 1, 0, 0 },\n        { 1, 0, 1, 1 },\n      }\n    ) ==\n    4;\n    assert longestLine(new int[][] { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 0, 0 } }) ==\n    1;\n\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-41","language":"java","prompt":"class Problem {\n\n  \/**\n   * Given an integer n, add a dot ('.') as a thousand separator every three digits and return the result as a string.\n   *\n   * @param n The integer to add thousand separators to.\n   * @return The string with thousand separators added.\n   *\n   * Example:\n   * addThousandSeparator(987)\n   * Output: \"987\"\n   *\n   * Example:\n   * addThousandSeparator(1234)\n   * Output: \"1.234\"\n   *\n   * Example:\n   * addThousandSeparator(123456789)\n   * Output: \"123.456.789\"\n   *\n   * Example:\n   * addThousandSeparator(0)\n   * Output: \"0\"\n   *\/\n  public static String addThousandSeparator(int n) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    assert \"2.147.483.647\".equals(\n        addThousandSeparator(2147483647)\n      ) : \"Test case 1 failed\";\n    assert \"10.000\".equals(addThousandSeparator(10000)) : \"Test case 2 failed\";\n    assert \"999\".equals(addThousandSeparator(999)) : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-42","language":"java","prompt":"import java.util.HashSet;\nimport java.util.Set;\n\nclass Problem {\n\n  \/**\n   * Given a non-negative integer array A, if the sum of each pair of adjacent elements in the array is a perfect square, then the array is considered a square array.\n   * Return the number of square permutations of A. Two permutations A1 and A2 are considered different if there exists an index i such that A1[i] != A2[i].\n   *\n   * @param A The input non-negative integer array.\n   * @return The number of square permutations of A.\n   *\n   * Example:\n   * squarePermutations(new int[]{1, 17, 8})\n   * Output: 2\n   *\n   * Example:\n   * squarePermutations(new int[]{2, 2, 2})\n   * Output: 1\n   *\/\n  public static int squarePermutations(int[] A) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    assert squarePermutations(new int[] { 1, 8, 27 }) == 0;\n    assert squarePermutations(new int[] { 1, 8, 17 }) == 2;\n    assert squarePermutations(new int[] { 4, 1, 3, 0, 2 }) == 0;\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-43","language":"java","prompt":"import java.util.*;\nclass Problem {\n\n  \/**\n   * Given n non-negative integers representing the heights of bars in a bar chart.\n   * Each bar has a width of 1 unit. Calculate the largest rectangle area that can be formed in the bar chart.\n   *\n   * @param heights An array of integers representing the heights of bars.\n   * @return The maximum area of the rectangle that can be formed.\n   *\n   * Example:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Output: 10\n   *\n   * Example:\n   * largestRectangleArea(new int[]{2,4})\n   * Output: 4\n   *\/\n  public static int largestRectangleArea(int[] heights) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    assert largestRectangleArea(new int[] { 1, 2, 3, 4, 5, 3, 3, 2 }) == 15;\n    assert largestRectangleArea(new int[] { 6, 2, 5, 4, 5, 1, 6 }) == 12;\n    assert largestRectangleArea(new int[] { 2, 1, 2, 3, 1 }) == 5;\n\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-44","language":"java","prompt":"import java.util.ArrayList;\n\nclass Problem {\n\n  \/**\n   * Return all elements in the matrix in diagonal order.\n   *\n   * @param mat The input matrix.\n   * @return An array containing all elements in diagonal order.\n   *\n   * Example:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * Output: [1,2,4,7,5,3,6,8,9]\n   *\/\n  public static int[] diagonalOrder(int[][] mat) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    assert java.util.Arrays.equals(\n      diagonalOrder(new int[][] { { 1, 2 }, { 3, 4 } }),\n      new int[] { 1, 2, 3, 4 }\n    );\n    assert java.util.Arrays.equals(\n      diagonalOrder(\n        new int[][] { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } }\n      ),\n      new int[] { 1, 2, 5, 9, 6, 3, 4, 7, 10, 11, 8, 12 }\n    );\n    assert java.util.Arrays.equals(\n      diagonalOrder(new int[][] { { 1 }, { 2 }, { 3 } }),\n      new int[] { 1, 2, 3 }\n    );\n\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-45","language":"java","prompt":"class Problem {\n\n  \/**\n   * Find the smallest integer that can be formed by rearranging the digits of the given positive integer n, which is greater than n.\n   *\n   * @param n The input positive integer.\n   * @return The smallest rearranged integer greater than n, or -1 if not possible.\n   *\n   * Example:\n   * findSmallestInteger(12)\n   * Output: 21\n   *\/\n  public static int findSmallestInteger(int n) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    assert findSmallestInteger(123) == 132;\n    assert findSmallestInteger(531) == -1;\n    assert findSmallestInteger(2071) == 2107;\n\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-46","language":"java","prompt":"import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nclass Problem {\n\n  \/**\n   * Given an integer n, return all the center symmetric numbers of length n.\n   *\n   * @param n The length of the center symmetric numbers.\n   * @return A list of center symmetric numbers.\n   *\n   * Example:\n   * centerSymmetricNumbers(2)\n   * Output: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Output: [\"0\",\"1\",\"8\"]\n   *\/\n  public static List<String> centerSymmetricNumbers(int n) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  private static void assertArrays(String[] expected, List<String> actual) {\n    if (actual == null || actual.size() != expected.length) {\n      throw new AssertionError(\"Test case failed\");\n    }\n    for (String str : expected) {\n      if (!actual.contains(str)) {\n        throw new AssertionError(\"Test case failed\");\n      }\n    }\n  }\n\n  public static void main(String[] args) {\n    assertArrays(\n      new String[] { \"11\", \"69\", \"88\", \"96\" },\n      centerSymmetricNumbers(2)\n    );\n    assertArrays(new String[] { \"0\", \"1\", \"8\" }, centerSymmetricNumbers(1));\n    assertArrays(\n      new String[] {\n        \"101\",\n        \"111\",\n        \"181\",\n        \"609\",\n        \"619\",\n        \"689\",\n        \"808\",\n        \"818\",\n        \"888\",\n        \"906\",\n        \"916\",\n        \"986\",\n      },\n      centerSymmetricNumbers(3)\n    );\n    System.out.println(\"All tests passed\");\n  }\n}\n","stop_tokens":[]}
{"name":"Java-47","language":"java","prompt":"class Problem {\n\n  \/**\n   * Determine if the given points form a boomerang on the X-Y plane.\n   *\n   * @param points An array of points where points[i] = [xi, yi].\n   * @return True if the points form a boomerang, false otherwise.\n   *\n   * Example:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Output: true\n   *\/\n  public static boolean isBoomerang(int[][] points) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    assert isBoomerang(new int[][] { { 0, 0 }, { 2, 2 }, { 1, 1 } }) ==\n    false : \"Test case 1 failed\";\n    assert isBoomerang(new int[][] { { 1, 1 }, { 2, 4 }, { 3, 1 } }) ==\n    true : \"Test case 2 failed\";\n    assert isBoomerang(new int[][] { { 0, 1 }, { 1, 0 }, { 0, -1 } }) ==\n    true : \"Test case 3 failed\";\n\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-48","language":"java","prompt":"import java.lang.Math;\n\nclass Problem {\n\n  \/**\n   * Find and return the nth ugly number.\n   *\n   * @param n The index of the ugly number to find.\n   * @return The nth ugly number.\n   *\n   * Example:\n   * findNthUglyNumber(10)\n   * Output: 12\n   *\/\n  public static int findNthUglyNumber(int n) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    assert findNthUglyNumber(1) == 1 : \"Test case 1 failed\";\n    assert findNthUglyNumber(7) == 8 : \"Test case 2 failed\";\n    assert findNthUglyNumber(15) == 24 : \"Test case 3 failed\";\n\n    System.out.println(\"All tests passed\");\n  }\n}\n","stop_tokens":[]}
{"name":"Java-49","language":"java","prompt":"class Problem {\n\n  \/**\n   * Calculate the energy of the string, which is defined as the length of the longest non-empty substring containing only one character.\n   *\n   * @param s The input string.\n   * @return The energy of the string.\n   *\n   * Example:\n   * calculateEnergy(\"aabbccdd\")\n   * Output: 2\n   *\/\n  public static int calculateEnergy(String s) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    \/\/ Test cases\n    assert calculateEnergy(\"aabbccdd\") == 2 : \"Test case 1 failed\"; \/\/ Contains two characters 'aa', 'bb', 'cc', 'dd'\n    assert calculateEnergy(\"horizon\") == 1 : \"Test case 2 failed\"; \/\/ All characters are unique\n    assert calculateEnergy(\"success\") == 2 : \"Test case 3 failed\"; \/\/ Contains three characters 'ccc'\n\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-50","language":"java","prompt":"import java.util.ArrayList;\nimport java.util.List;\n\nclass Problem {\n\n  \/**\n   * Return all integers in the range [1, n] in lexicographical order.\n   *\n   * @param n The upper limit of the range.\n   * @return List of integers in lexicographical order.\n   *\n   * Example:\n   * lexicalOrder(13)\n   * Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   *\/\n  public static List<Integer> lexicalOrder(int n) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    \/\/ Test cases\n    assert lexicalOrder(13)\n      .equals(\n        new ArrayList<Integer>() {\n          {\n            add(1);\n            add(10);\n            add(11);\n            add(12);\n            add(13);\n            add(2);\n            add(3);\n            add(4);\n            add(5);\n            add(6);\n            add(7);\n            add(8);\n            add(9);\n          }\n        }\n      ) : \"Test case 1 failed\";\n\n    assert lexicalOrder(20)\n      .equals(\n        new ArrayList<Integer>() {\n          {\n            add(1);\n            add(10);\n            add(11);\n            add(12);\n            add(13);\n            add(14);\n            add(15);\n            add(16);\n            add(17);\n            add(18);\n            add(19);\n            add(2);\n            add(20);\n            add(3);\n            add(4);\n            add(5);\n            add(6);\n            add(7);\n            add(8);\n            add(9);\n          }\n        }\n      ) : \"Test case 2 failed\";\n\n    assert lexicalOrder(2)\n      .equals(\n        new ArrayList<Integer>() {\n          {\n            add(1);\n            add(2);\n          }\n        }\n      ) : \"Test case 3 failed\";\n\n    System.out.println(\"All tests passed\");\n  }\n}\n","stop_tokens":[]}
{"name":"Java-51","language":"java","prompt":"import java.util.HashMap;\n\nclass Problem {\n\n  \/**\n   * Calculate the sum of unique elements in the given integer array.\n   *\n   * @param nums An array of integers.\n   * @return The sum of unique elements.\n   *\n   * Example:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * Output: 4\n   *\/\n  public static int calculateUniqueSum(int[] nums) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    assert calculateUniqueSum(new int[] { 1, 4, 5, 1, 2, 4 }) == 7; \/\/ Test Case 1\n    assert calculateUniqueSum(new int[] { 0, 0, 0, 0 }) == 0; \/\/ Test Case 2\n    assert calculateUniqueSum(new int[] { -1, -2, -3, -2 }) == -4; \/\/ Test Case 3\n\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-52","language":"java","prompt":"class Problem {\n\n  \/**\n   * Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n   *\n   * @param n The target integer.\n   * @return The minimum number of perfect square numbers.\n   *\n   * Example:\n   * minPerfectSquareSum(12)\n   * Output: 3\n   *\n   * Example:\n   * minPerfectSquareSum(13)\n   * Output: 2\n   *\/\n  public static int minPerfectSquareSum(int n) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    assert minPerfectSquareSum(26) == 2 : \"Test case 1 failed\";\n    assert minPerfectSquareSum(17) == 2 : \"Test case 2 failed\";\n    assert minPerfectSquareSum(99) == 3 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
{"name":"Java-53","language":"java","prompt":"class Problem {\n\n  \/**\n   * Reverse the characters of each word in the given string while maintaining the original word order.\n   *\n   * @param s The input string containing words separated by spaces.\n   * @return The string with characters of each word reversed.\n   *\n   * Example:\n   * reverseWords(\"Mr Ding\")\n   * Output: \"rM gniD\"\n   *\/\n  public static String reverseWords(String s) ","doctests":"transforms","original":" ","prompt_terminology":"reworded","tests":"  public static void main(String[] args) {\n    assert reverseWords(\"The quick brown fox\").equals(\"ehT kciuq nworb xof\") : \"Test failed for input: The quick brown fox\";\n    assert reverseWords(\"Hello World\").equals(\"olleH dlroW\") : \"Test failed for input: Hello World\";\n    assert reverseWords(\"a b c d e f\").equals(\"a b c d e f\") : \"Test failed for input: a b c d e f\";\n    System.out.println(\"All tests passed\");\n  }\n}","stop_tokens":[]}
